# Classic Bricks JS - 개발 계획서

## 1. 개요 (Overview)

**프로젝트 목표**: JavaScript와 HTML5 Canvas를 사용하여 고전적인 Breakout/Arkanoid 스타일의 벽돌 깨기 게임을 개발하고, 웹 브라우저에서 직접 실행 가능하며 웹 블로그에 연동한다. (참조: `requirement.md`)

**핵심 가치**:
-   **웹 표준 준수**: HTML5, CSS3, JavaScript(ES6+)를 사용하여 개발한다.
-   **경량화 및 성능**: 외부 라이브러리 의존성을 최소화하고, `requestAnimationFrame`을 통한 부드러운 애니메이션을 구현한다.
-   **모듈화 및 유지보수성**: 각 게임 요소를 모듈로 분리하여 코드의 가독성과 유지보수성을 높인다.
-   **단계적 개발**: 핵심 기능부터 구현하여 점진적으로 기능을 확장한다.

## 2. 개발 단계 (Development Phases)

### 단계 0: 프로젝트 설정 및 기본 HTML 구조 (0.5일)
-   **작업 내용**:
    -   프로젝트 폴더 구조 설정 (`index.html`, `css/style.css`, `js/main.js`, `js/game.js`, `js/components/paddle.js`, `js/components/ball.js`, `js/components/brick.js`, `js/utils/collision.js` 등).
    -   기본 `index.html` 파일 작성: Canvas 요소 포함.
    -   기본 `style.css` 파일 작성: Canvas 및 기본 UI 스타일링.
    -   `main.js`: 게임 초기화 및 시작 로직.
-   **산출물**: 기본 HTML 페이지에 빈 Canvas 영역 표시.

### 단계 1: 핵심 게임 요소 구현 (Canvas) (1.5일)
-   **작업 내용**:
    -   **Canvas 초기화**: `game.js`에서 Canvas 컨텍스트 가져오기 및 기본 설정.
    -   **패들(Paddle) 구현 (Canvas)**:
        -   `paddle.js`: 패들 클래스 (위치, 크기, Canvas 색상, 이동 속도).
        -   Canvas API를 사용하여 사각형으로 패들 그리기.
        -   키보드 입력(좌우 화살표)에 따른 패들 이동 로직 (화면 경계 이탈 방지).
    -   **공(Ball) 구현 (Canvas)**:
        -   `ball.js`: 공 클래스 (위치, 반지름, Canvas 색상, 속도(dx, dy)).
        -   Canvas API를 사용하여 원으로 공 그리기.
        -   공 자동 이동 로직.
-   **산출물**: 화면 하단에서 좌우로 움직이는 Canvas로 그려진 패들과 화면 내에서 움직이는 Canvas로 그려진 공.

### 단계 2: 충돌 감지 및 기본 물리 (Canvas) (2일)
-   **작업 내용**:
    -   **벽 충돌**: Canvas로 그려진 공이 화면 상단 및 좌우 벽에 닿으면 튕겨 나오도록 구현 (`ball.js`).
    -   **패들 충돌**: Canvas로 그려진 공이 Canvas로 그려진 패들에 닿으면 튕겨 나오도록 구현 (`collision.js`, `ball.js`).
        -   단순 반사각 또는 패들 위치에 따른 반사각 조절 (선택 사항).
    -   **공 놓침 (생명 감소 전 단계)**: 공이 화면 하단으로 벗어나는 것 감지.
-   **산출물**: Canvas로 그려진 공이 벽과 패들에 정상적으로 충돌하고 반사됨.

### 단계 3: 벽돌(Bricks) 구현 및 파괴 (Canvas) (2일)
-   **작업 내용**:
    -   **벽돌 클래스 (Canvas)**: `brick.js`: 벽돌 클래스 (위치, 크기, Canvas 색상, 상태(활성/파괴됨), 점수).
    -   **벽돌 배치**: `game.js` 또는 `level.js` (추후 생성)에서 여러 벽돌을 화면 상단에 배열 형태로 배치. 모든 벽돌은 Canvas API로 그려짐.
    -   **공과 벽돌 충돌**:
        -   `collision.js`: Canvas 공과 각 Canvas 벽돌 간의 충돌 감지.
        -   충돌 시 해당 벽돌 파괴 (상태 변경) 및 공 반사.
-   **산출물**: 화면에 배치된 Canvas 벽돌들이 공에 맞아 사라짐.

### 단계 4: 반응형 디자인 및 화면 적응 구현 (1.5일)
-   **작업 내용**:
    -   **반응형 Canvas 크기 조정**:
        -   다양한 스크린 크기(모바일, 태블릿, 노트북, 데스크탑)에 맞게 Canvas 요소 크기 자동 조정 로직 구현.
        -   `window.innerWidth`와 `window.innerHeight`를 활용한 화면 크기 감지.
        -   화면 크기에 따른 Canvas 비율 조정 (가로세로 비율 유지).
    -   **UI 요소 배치 최적화**:
        -   화면 크기에 따라 패들, 공, 벽돌의 크기와 위치를 비율적으로 조정하는 스케일링 시스템 구현.
        -   점수, 생명, 버튼 등 UI 요소의 크기와 위치도 화면 크기에 맞게 자동 조정.
    -   **뷰포트 설정**:
        -   HTML 파일에 적절한 meta viewport 태그 추가.
        -   터치 입력과 마우스 입력 모두 지원하도록 이벤트 리스너 구현.
    -   **가시 영역 최적화**:
        -   모든 게임 요소가 디바이스 화면 내에 온전히 표시되도록 배치 조정.
        -   스크롤 없이 전체 게임 플레이가 가능하도록 요소 배치 최적화.
    -   **디바이스 특화 조정**:
        -   모바일: 손가락으로 쉽게 컨트롤할 수 있는 터치 영역 최적화.
        -   노트북: 작은 화면에서도 모든 요소가 온전히 표시되도록 밸런스 조정.
        -   데스크탑: 큰 화면에서 게임 요소가 너무 작아 보이지 않도록 비율 조정.
    -   **반응형 테스트**:
        -   다양한 해상도 및 화면 크기에서의 동작 테스트 (320px부터 1920px+ 너비).
        -   Chrome DevTools의 Device Mode를 활용한 다양한 디바이스 환경 시뮬레이션.
    -   **iframe(임베디드) 통합 대응**:
        -   blog/index.html의 "My Games" 섹션에서 iframe으로 게임이 임베드되는 상황을 고려해, Canvas 및 UI가 iframe 내부에서도 짤림 없이 표시되도록 설계.
        -   iframe의 크기 변화(특히 모바일/태블릿에서의 가로세로 전환)에 따라 Canvas 및 UI가 자동으로 리사이즈되도록 이벤트 리스너 및 스타일 적용.
        -   iframe 부모 컨테이너의 크기 제한(최소/최대 width, height 등)을 고려하여, 내부 게임이 항상 스크롤 없이 플레이 가능하도록 레이아웃 설계.
-   **산출물**: 다양한 스크린 크기 및 iframe 환경에서 스크롤 없이 모든 게임 요소가 온전히 표시되며 플레이할 수 있는 반응형 게임 화면.

### 단계 5: 게임 시스템 (점수, 생명, 게임 상태 - Canvas UI) (1.5일)
-   **작업 내용**:
    -   **점수 시스템**:
        -   벽돌 파괴 시 점수 증가.
        -   Canvas API를 사용하여 화면에 현재 점수 표시.
    -   **생명 시스템**:
        -   초기 생명 설정 (예: 3개).
        -   공을 놓칠 때마다 생명 1개 감소.
        -   Canvas API를 사용하여 화면에 남은 생명 표시.
    -   **게임 상태 관리**:
        -   게임 시작 (공 발사 전 대기 상태).
        -   게임 오버 (생명이 0이 되었을 때).
        -   게임 재시작 기능.
-   **산출물**: Canvas UI로 점수와 생명이 화면에 표시되고, 게임 오버 및 재시작 기능 동작.

### 단계 6: 스테이지 및 난이도 (선택적 확장 - 1.5일)
-   **작업 내용**:
    -   **레벨 데이터 구조화**: `levels.js` 파일에 여러 스테이지의 벽돌 배치 정보 정의.
    -   **스테이지 전환**: 현재 스테이지의 모든 벽돌 파괴 시 다음 스테이지 로드.
    -   **난이도 조절**: 스테이지 진행에 따른 공 속도 증가 또는 특수 벽돌 등장 (선택 사항).
-   **산출물**: 여러 스테이지를 플레이할 수 있으며, 점진적으로 난이도 상승.

### 단계 7: 기본 UI/UX 개선 (Canvas) (1일)
-   **작업 내용**:
    -   게임 시작 화면, 게임 오버 화면 등 기본 UI를 Canvas API를 사용하여 구현 (텍스트, 도형 활용).
    -   게임 재시작 로직과 UI 연결.
    -   간단한 시각적 피드백 (예: 벽돌 파괴 시 Canvas 기반 효과).
-   **산출물**: Canvas로 구현된 기본 UI (시작, 게임오버 화면) 및 개선된 게임 흐름.

### 단계 8: 에셋 통합 (이미지 및 사운드) (1.5일)
-   **작업 내용**:
    -   게임 요소(패들, 공, 벽돌 등) 및 배경에 사용할 이미지 에셋 준비 (PNG 등).
    -   Canvas 도형 렌더링을 이미지 렌더링으로 교체 (`assets/images/` 폴더 활용).
    -   사운드 효과(공 튕기는 소리, 벽돌 깨지는 소리 등) 준비 (MP3, WAV 등).
    -   Web Audio API를 사용하여 사운드 효과 통합 (`assets/sounds/` 폴더 활용).
    -   (선택) `assets.js` 파일을 통해 에셋 로딩 관리 구현.
-   **산출물**: 이미지와 사운드가 적용되어 시청각적으로 향상된 게임.

### 단계 9: `blog/index.html` 연동 및 최종 테스트 (1일)
-   **작업 내용**:
    -   `blog/index.html`의 "My games" 섹션에 "Classic Bricks JS" 게임 카드 추가.
        -   썸네일 이미지 또는 CSS로 디자인된 플레이스홀더.
        -   클릭 시 게임 실행 로직 (`iframe` 또는 직접 페이지 로드).
    -   **iframe 통합 UI/UX 테스트**:
        -   게임이 iframe 내에서 임베드될 때, 모든 UI 요소가 짤림 없이 표시되는지 확인.
        -   모바일, 태블릿, 데스크탑 등 다양한 화면 크기에서 iframe 크기 변화에 따른 게임 UI의 자동 리사이즈 및 레이아웃 적응 테스트.
        -   필요 시, iframe 컨테이너와 내부 Canvas 사이의 통신(예: postMessage) 또는 스타일 조정 방안 문서화.
    -   `translations.js`에 게임 제목 및 설명 다국어 지원 추가.
    -   최종 테스트 및 버그 수정.
    -   크로스 브라우저 테스트 (Chrome, Firefox, Safari, Edge).
-   **산출물**: 블로그에 통합되고, 다양한 디바이스 및 iframe 환경에서도 안정적으로 실행되는 벽돌 깨기 게임.

## 3. 코드 구조 (예상)

```
brick_simulation_js/
├── index.html             // 메인 HTML 파일
├── css/
│   └── style.css          // CSS 스타일
├── js/
│   ├── main.js            // 게임 초기화 및 전역 관리
│   ├── game.js            // 게임 루프, 상태 관리, 렌더링 총괄
│   ├── components/
│   │   ├── paddle.js      // 패들 클래스 (초기 Canvas, 단계 7 이후 이미지)
│   │   ├── ball.js        // 공 클래스 (초기 Canvas, 단계 7 이후 이미지)
│   │   ├── brick.js       // 벽돌 클래스 (초기 Canvas, 단계 7 이후 이미지)
│   │   └── (item.js)      // (선택) 아이템 클래스
│   ├── utils/
│   │   ├── collision.js   // 충돌 감지 로직
│   │   ├── (input.js)     // (선택) 입력 처리 모듈
│   │   └── (helpers.js)   // (선택) 기타 유틸리티 함수
│   └── (assets.js)        // (단계 7 이후 선택) 이미지/사운드 로딩 관리
├── assets/                // (단계 7 이후 사용) 이미지, 사운드 파일
│   ├── images/            // (초기에는 비어 있거나 플레이스홀더만 존재)
│   └── sounds/            // (초기에는 비어 있거나 플레이스홀더만 존재)
└── requirement.md
└── development_plan.md
```

## 4. 기술 스택

-   **언어**: JavaScript (ES6+)
-   **플랫폼**: HTML5 (Canvas API)
-   **스타일링**: CSS3
-   **버전 관리**: Git

## 5. 비기능 요구사항 (참조: `requirement.md`)

-   **성능**: `requestAnimationFrame`을 사용하여 부드러운 애니메이션 (최소 30FPS, 권장 60FPS).
-   **호환성**: 주요 최신 웹 브라우저 (Chrome, Firefox, Safari, Edge)와 다양한 화면 크기 (모바일, 태블릿, 노트북, 데스크탑).
-   **유지보수성**: 명확하고 모듈화된 코드, 적절한 주석.
-   **반응형**: 모든 디바이스에서 스크롤 없이 전체 게임 화면이 표시되고 원활하게 플레이 가능.

## 6. 개발 일정 (요약)

-   **총 예상 기간**: 약 9~11.5일 (선택적 확장 포함 시)
    -   단계 0: 0.5일
    -   단계 1: 1.5일
    -   단계 2: 2일
    -   단계 3: 2일
    -   단계 4: 1.5일 (반응형 디자인 및 화면 적응 구현)
    -   단계 5 (선택): 1.5일
    -   단계 6: 1일 (기본 UI/UX 개선 - Canvas)
    -   단계 7: 1.5일 (에셋 통합 - 이미지/사운드)
    -   단계 8: 1일 (블로그 연동)

## 7. 추가 고려사항

-   **모바일 터치 컨트롤**: 터치 디바이스에서는 패들을 터치로 직접 조작하거나 화면을 탭하는 방식으로 컨트롤할 수 있도록 구현 고려. 이는 단계 4의 반응형 디자인 구현과 연계하여 개발.
-   **아이템 시스템**: Arkanoid 스타일의 아이템 (패들 확장, 공 속도 조절, 멀티볼 등)은 핵심 기능 구현 후 추가 고려.
-   **고급 그래픽/애니메이션**: 초기 단계(1~6)에서는 단순 Canvas 도형 및 효과 사용. 단계 7 (에셋 통합)에서 스프라이트 이미지 및 고급 애니메이션 적용 가능.
-   **디바이스 성능 최적화**: 저사양 디바이스에서도 게임이 원활하게 실행되도록 렌더링 최적화 기법 적용 고려 (특히 모바일 기기에서).
